<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NUCC Trip Attendance Sheet</title>
  <style>
    body {
      margin: 0;
      padding: 1.5rem;
      background: #f7f7f7;
      color: #222;
      font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    .top-section {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .top-section-left {
      flex: 1 1 320px;
      min-width: 280px;
    }

    .top-section-right {
      flex: 0 0 auto;
      text-align: right;
    }

    .top-section-right img {
      max-width: 180px;
      width: 100%;
      height: auto;
    }

    .header-row {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .header-row img {
      height: 72px;
      width: auto;
      display: block;
    }

    h1 {
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 1.4rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 1.5rem;
      background: #fff;
    }

    th,
    td {
      border: 1px solid #ccc;
      padding: 0.4rem 0.5rem;
      text-align: left;
      vertical-align: top;
    }

    thead th {
      background: #eaeaea;
      font-weight: 600;
      text-align: center;
    }

    caption {
      text-align: left;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    .meta-table th,
    .meta-table td {
      border-color: #999;
    }

    .meta-table thead th {
      background: #f0f0f0;
    }

    .expense-toggle-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin: 1rem 0;
    }

    .expense-toggle-group label {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-weight: 500;
    }

    .base-expense-inputs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }

    .base-expense-inputs label {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 500;
    }

    .base-expense-inputs input[type="number"] {
      width: 6rem;
      padding: 0.35rem 0.45rem;
      border-radius: 0.35rem;
      border: 1px solid #999;
      font-weight: 500;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: flex-start;
      margin-top: 1rem;
    }

    .control-button {
      padding: 0.5rem 0.9rem;
      font-size: 0.95rem;
      border-radius: 0.4rem;
      border: 1px solid #0077b6;
      background: #0096c7;
      color: #fff;
      cursor: pointer;
    }

    .control-button:hover {
      background: #00a8e8;
    }

    .warning-message {
      color: #b00020;
      font-weight: 600;
      margin: 0.5rem 0 0;
    }

    .name-input.duplicate-name {
      border-color: #b00020;
      background: #ffe8ec;
    }

    .read-only-amount {
      background: #f5f5f5;
      color: #555;
    }

    #notify-dialog {
      border: none;
      border-radius: 0.75rem;
      padding: 0;
      max-width: min(960px, 90vw);
      width: 100%;
      color: #222;
      box-shadow: 0 1.5rem 3rem rgba(0, 0, 0, 0.2);
    }

    #notify-dialog::backdrop {
      background: rgba(0, 0, 0, 0.35);
    }

    .notify-container {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 1.5rem;
      background: #fff;
      max-height: 80vh;
      box-sizing: border-box;
    }

    .notify-dialog-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .notify-dialog-header h2 {
      margin: 0;
      font-size: 1.25rem;
    }

    .notify-close-button {
      border: none;
      background: transparent;
      font-size: 1.75rem;
      line-height: 1;
      cursor: pointer;
      color: #444;
    }

    .notify-close-button:hover,
    .notify-close-button:focus {
      color: #000;
    }

    .notify-preview {
      border: 1px solid #d0d0d0;
      border-radius: 0.5rem;
      overflow: auto;
      max-height: 45vh;
      padding: 1rem;
      background: #fff;
    }

    .notify-preview table {
      background: #fff;
    }

    .notify-preview input,
    .notify-preview textarea,
    .notify-preview select,
    .notify-preview button {
      pointer-events: none;
    }

    .notify-domains {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .notify-domain-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .notify-domain-group label {
      font-weight: 600;
    }

    .notify-domain-textarea {
      width: 100%;
      min-height: 4rem;
      resize: vertical;
      font: inherit;
      padding: 0.5rem;
      border: 1px solid #bdbdbd;
      border-radius: 0.4rem;
      background: #f9f9f9;
    }

    .notify-domain-textarea[readonly] {
      background: #f3f3f3;
    }

    .attendance-table input[type="text"],
    .attendance-table input[type="number"],
    .attendance-table textarea,
    .meta-table input[type="text"],
    .signature-textarea {
      width: 100%;
      box-sizing: border-box;
      font: inherit;
      padding: 0.3rem;
      border: 1px solid #bdbdbd;
      border-radius: 0.3rem;
      background: #fff;
    }

    .consume-header {
      width: 2.5rem;
    }

    .consume-cell {
      text-align: center;
      width: 2.5rem;
    }

    .attendance-table input[type="number"] {
      text-align: right;
    }

    .attendance-table textarea {
      min-height: 2.2rem;
      resize: vertical;
    }

    .signature-textarea {
      min-height: 4.5rem;
      resize: vertical;
    }

    .name-input-wrapper {
      display: flex;
      gap: 0.25rem;
      align-items: center;
    }

    .name-select {
      width: 1.75rem;
      min-width: 1.75rem;
      padding: 0.2rem;
      border: 1px solid #bdbdbd;
      border-radius: 0.3rem;
      background: #fff;
      font: inherit;
      height: 100%;
      cursor: pointer;
    }

    .name-input.bold {
      font-weight: 600;
    }

    .totals-row td {
      font-weight: 600;
      background: #f4f4f4;
    }

    .totals-row em {
      font-weight: 400;
      color: #666;
    }

    .fee-breakdown,
    .fee-value,
    .reimbursed-value {
      text-align: right;
      white-space: nowrap;
    }

    .expense-total,
    .expense-consumers {
      font-size: 0.85rem;
      color: #333;
    }

    .club-income-table th {
      text-align: left;
    }

    .signature-cell {
      min-width: 12rem;
      border-bottom: 1px solid #333;
    }

    @media (max-width: 1100px) {
      body {
        padding: 1rem;
      }

      table {
        font-size: 0.9rem;
      }

      .top-section-right {
        text-align: center;
        width: 100%;
      }

      .top-section-right img {
        max-width: 150px;
      }

      .controls {
        justify-content: flex-start;
      }

      .control-button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="top-section">
    <div class="top-section-left">
      <div class="header-row">
        <img src="banner.png" alt="NUCC banner" />
        <h1>Trip Attendance Sheet</h1>
      </div>

      <table class="meta-table">
        <tbody>
          <tr>
            <th scope="row">Date</th>
            <td><input type="date" value="2025-07-27" /></td>
            <th scope="row">Location</th>
            <td><input type="text" value="Drum" /></td>
            <th scope="row">Trip Leader</th>
            <td><input type="text" value="Rowan" /></td>
          </tr>
        </tbody>
      </table>

      <div class="expense-toggle-group" role="group" aria-label="Expense Columns">
        <label>
          <input type="checkbox" data-expense-key="personal-gear" checked />
          Personal Gear
        </label>
        <label>
          <input type="checkbox" data-expense-key="shared-gear" checked />
          Shared Gear
        </label>
        <label>
          <input type="checkbox" data-expense-key="petrol" checked />
          Petrol
        </label>
      </div>

      <div class="base-expense-inputs">
        <label for="personal-gear-rate">
          Personal Gear per person ($)
          <input type="number" id="personal-gear-rate" step="0.01" />
        </label>
        <label for="shared-gear-rate">
          Shared Gear per person ($)
          <input type="number" id="shared-gear-rate" step="0.01" />
        </label>
      </div>

      <div class="controls">
        <button class="control-button" type="button" id="add-row">Add Row</button>
        <button class="control-button" type="button" id="remove-row">Remove Row</button>
        <button class="control-button" type="button" id="add-expense">Add Expense</button>
        <button class="control-button" type="button" id="remove-expense">Remove Expense</button>
        <button class="control-button" type="button" id="save-csv">Save CSV</button>
        <button class="control-button" type="button" id="load-csv">Load CSV</button>
        <button class="control-button" type="button" id="notify-button">Notify</button>
      </div>
    </div>
    <div class="top-section-right">
      <img src="taxminer.png" alt="Tax Miner graphic" />
    </div>
  </div>

  <p
    id="duplicate-name-warning"
    class="warning-message"
    role="alert"
    aria-live="polite"
    hidden
  ></p>

  <table class="attendance-table" id="attendance-table">
    <thead>
      <tr id="attendance-header">
        <th>Name</th>
      </tr>
    </thead>
    <tbody id="attendance-body"></tbody>
    <tfoot id="attendance-foot"></tfoot>
  </table>

  <input
    type="file"
    id="load-csv-input"
    accept=".csv,text/csv"
    style="position: absolute; left: -10000px;"
    aria-hidden="true"
  />

  <dialog id="notify-dialog" aria-labelledby="notify-dialog-title">
    <div class="notify-container">
      <div class="notify-dialog-header">
        <h2 id="notify-dialog-title">Notify Members</h2>
        <button
          type="button"
          class="notify-close-button"
          id="notify-close"
          aria-label="Close notify dialog"
        >
          &times;
        </button>
      </div>
      <div class="notify-preview" id="notify-preview"></div>
      <div class="notify-domains" id="notify-domain-groups"></div>
    </div>
  </dialog>

  <section>
    <table class="club-income-table">
      <tbody>
        <tr>
          <th scope="row">Club Income</th>
          <td id="club-income-value"></td>
          <th scope="row" style="text-align: right;">Signature</th>
          <td class="signature-cell" id="signature-output"></td>
        </tr>
      </tbody>
    </table>

    <table>
      <tbody>
        <tr>
          <th scope="row">Comments</th>
          <th scope="row">Equipment</th>
        </tr>
        <tr>
          <td>
            <textarea id="signature-comments" class="signature-textarea"></textarea>
          </td>
          <td></td>
        </tr>
      </tbody>
    </table>
  </section>

  <script>
    const nameListId = "member-options";
    const nameDatalist = document.createElement("datalist");
    nameDatalist.id = nameListId;
    document.body.appendChild(nameDatalist);

    let memberNames = [];
    let memberRecords = [];

    const baseExpenseRates = {
      "personal-gear": "",
      "shared-gear": ""
    };

    const baseExpenseKeys = Object.keys(baseExpenseRates);

    const participants = [{ name: "", bold: false, notes: "" }];

    const baseExpenseDefinitions = [
      { key: "personal-gear", name: "Personal Gear", enabled: true },
      { key: "shared-gear", name: "Shared Gear", enabled: true },
      { key: "petrol", name: "Petrol", enabled: true }
    ];

    let customExpenseCounter = 0;

    function createExpense({ name, key = null, type = "custom", enabled = true }) {
      const id = type === "base" ? `base-${key}` : `custom-${customExpenseCounter++}`;
      return {
        id,
        name,
        key,
        type,
        enabled,
        amounts: participants.map(() => ""),
        consumers: participants.map(() => true)
      };
    }

    const baseExpenses = baseExpenseDefinitions.map((definition) =>
      createExpense({ ...definition, type: "base" })
    );

    const customExpenses = [];

    const baseExpenseRateInputs = {
      "personal-gear": document.getElementById("personal-gear-rate"),
      "shared-gear": document.getElementById("shared-gear-rate")
    };

    function isBaseRateControlled(expense) {
      if (!expense || !expense.key) {
        return false;
      }
      return Object.prototype.hasOwnProperty.call(baseExpenseRates, expense.key);
    }

    function applyBaseExpenseRateToExpense(key) {
      const expense = baseExpenses.find((item) => item.key === key);
      if (!expense) {
        return;
      }
      ensureExpenseSize(expense);
      const rate = baseExpenseRates[key];
      for (let index = 0; index < expense.amounts.length; index += 1) {
        expense.amounts[index] = rate === "" ? "" : rate;
      }
    }

    function syncBaseExpenseInputsFromRates() {
      baseExpenseKeys.forEach((key) => {
        const input = baseExpenseRateInputs[key];
        if (!input) {
          return;
        }
        const value = baseExpenseRates[key];
        input.value = value === "" ? "" : String(value);
      });
    }

    function updateDuplicateNameWarnings() {
      const nameInputs = Array.from(document.querySelectorAll(".name-input"));
      const warningElement = document.getElementById("duplicate-name-warning");
      const counts = new Map();

      nameInputs.forEach((input) => {
        const normalized = input.value.trim().toLowerCase();
        if (!normalized) {
          return;
        }
        counts.set(normalized, (counts.get(normalized) || 0) + 1);
      });

      const duplicateKeys = new Set();
      counts.forEach((count, key) => {
        if (count > 1) {
          duplicateKeys.add(key);
        }
      });

      nameInputs.forEach((input) => {
        const normalized = input.value.trim().toLowerCase();
        if (normalized && duplicateKeys.has(normalized)) {
          input.classList.add("duplicate-name");
          input.setAttribute("aria-invalid", "true");
        } else {
          input.classList.remove("duplicate-name");
          input.removeAttribute("aria-invalid");
        }
      });

      if (warningElement) {
        if (duplicateKeys.size > 0) {
          const labels = [];
          duplicateKeys.forEach((key) => {
            const matchingInput = nameInputs.find(
              (input) => input.value.trim().toLowerCase() === key
            );
            if (matchingInput) {
              const trimmed = matchingInput.value.trim();
              if (trimmed && !labels.includes(trimmed)) {
                labels.push(trimmed);
              }
            }
          });
          warningElement.hidden = false;
          warningElement.textContent = `Duplicate names detected: ${labels.join(", ")}`;
        } else {
          warningElement.hidden = true;
          warningElement.textContent = "";
        }
      }
    }

    baseExpenseKeys.forEach((key) => {
      const input = baseExpenseRateInputs[key];
      if (!input) {
        return;
      }
      input.addEventListener("input", () => {
        const rawValue = input.value;
        if (rawValue === "") {
          baseExpenseRates[key] = "";
          applyBaseExpenseRateToExpense(key);
          renderTable();
          syncBaseExpenseInputsFromRates();
          return;
        }
        const numericValue = Number(rawValue);
        if (!Number.isFinite(numericValue)) {
          return;
        }
        baseExpenseRates[key] = numericValue;
        applyBaseExpenseRateToExpense(key);
        renderTable();
        syncBaseExpenseInputsFromRates();
      });
    });

    function getAllExpenses() {
      return [...baseExpenses, ...customExpenses];
    }

    function getActiveExpenses() {
      return [
        ...baseExpenses.filter((expense) => expense.enabled),
        ...customExpenses
      ];
    }

    function findExpenseById(id) {
      return getAllExpenses().find((expense) => expense.id === id);
    }

    function populateNameSelect(selectElement) {
      selectElement.innerHTML = "";

      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "";
      placeholder.setAttribute("aria-hidden", "true");
      selectElement.appendChild(placeholder);

      memberNames.forEach((name) => {
        const option = document.createElement("option");
        option.value = name;
        option.textContent = name;
        selectElement.appendChild(option);
      });

      selectElement.value = "";
    }

    function cloneNodeWithFormValues(node) {
      const clone = node.cloneNode(true);
      const originals = node.querySelectorAll("input, textarea, select");
      const clones = clone.querySelectorAll("input, textarea, select");
      originals.forEach((element, index) => {
        const cloned = clones[index];
        if (!cloned) {
          return;
        }
        if (cloned.tagName === "INPUT") {
          const input = element;
          const cloneInput = cloned;
          if (input.type === "checkbox" || input.type === "radio") {
            cloneInput.checked = input.checked;
          } else {
            cloneInput.value = input.value;
          }
        } else if (cloned.tagName === "TEXTAREA" || cloned.tagName === "SELECT") {
          cloned.value = element.value;
        }
      });
      return clone;
    }

    function stripIds(node) {
      if (node.nodeType === Node.ELEMENT_NODE) {
        node.removeAttribute("id");
        node
          .querySelectorAll("[id]")
          .forEach((element) => element.removeAttribute("id"));
      }
      return node;
    }

    function buildDomainContactGroups() {
      const domainMap = new Map();
      memberRecords.forEach((record) => {
        const contactValue = record.contact;
        if (!contactValue) {
          return;
        }
        String(contactValue)
          .split(/[;,\s]+/)
          .map((piece) => piece.trim())
          .filter(Boolean)
          .forEach((entry) => {
            const normalizedEntry = entry.toLowerCase();
            const atIndex = normalizedEntry.lastIndexOf("@");
            if (atIndex === -1 || atIndex === normalizedEntry.length - 1) {
              return;
            }
            const domain = normalizedEntry.slice(atIndex + 1);
            if (!domainMap.has(domain)) {
              domainMap.set(domain, new Map());
            }
            const contactsForDomain = domainMap.get(domain);
            if (!contactsForDomain.has(normalizedEntry)) {
              contactsForDomain.set(normalizedEntry, entry);
            }
          });
      });

      return new Map(
        Array.from(domainMap.entries()).sort(([domainA], [domainB]) =>
          domainA.localeCompare(domainB)
        )
      );
    }

    function renderNotifyPreview() {
      const preview = document.getElementById("notify-preview");
      if (!preview) {
        return;
      }
      preview.innerHTML = "";

      const sections = [];
      const topSection = document.querySelector(".top-section");
      if (topSection) {
        sections.push(topSection);
      }
      const attendanceTable = document.getElementById("attendance-table");
      if (attendanceTable) {
        sections.push(attendanceTable);
      }
      const summarySection = document.querySelector("section");
      if (summarySection) {
        sections.push(summarySection);
      }

      sections.forEach((section) => {
        const clone = stripIds(cloneNodeWithFormValues(section));
        if (clone) {
          preview.appendChild(clone);
        }
      });
    }

    function renderDomainGroups() {
      const container = document.getElementById("notify-domain-groups");
      if (!container) {
        return;
      }
      container.innerHTML = "";

      const domainGroups = buildDomainContactGroups();
      if (domainGroups.size === 0) {
        const emptyMessage = document.createElement("p");
        emptyMessage.textContent = "No member contact information available.";
        container.appendChild(emptyMessage);
        return;
      }

      domainGroups.forEach((contactsMap, domain) => {
        const wrapper = document.createElement("div");
        wrapper.className = "notify-domain-group";

        const label = document.createElement("label");
        label.textContent = `${domain} (${contactsMap.size})`;
        wrapper.appendChild(label);

        const textarea = document.createElement("textarea");
        textarea.className = "notify-domain-textarea";
        textarea.readOnly = true;
        const contacts = Array.from(contactsMap.values()).sort((a, b) =>
          a.localeCompare(b)
        );
        textarea.value = contacts.join(", ");
        textarea.setAttribute("aria-label", `Contacts for ${domain}`);
        textarea.addEventListener("focus", () => {
          textarea.select();
        });
        wrapper.appendChild(textarea);

        container.appendChild(wrapper);
      });
    }

    function openNotifyDialog() {
      const dialog = document.getElementById("notify-dialog");
      if (!dialog) {
        return;
      }
      renderNotifyPreview();
      renderDomainGroups();
      if (typeof dialog.showModal === "function") {
        dialog.showModal();
      } else {
        dialog.setAttribute("open", "open");
      }
    }

    function closeNotifyDialog() {
      const dialog = document.getElementById("notify-dialog");
      if (!dialog) {
        return;
      }
      if (typeof dialog.close === "function") {
        dialog.close();
      } else {
        dialog.removeAttribute("open");
      }
    }

    async function loadMemberOptions() {
      try {
        const response = await fetch("members.csv");
        if (!response.ok) {
          return;
        }
        const text = await response.text();
        const rows = parseCsv(text);
        const records = [];
        const names = new Set();

        rows.forEach((row, index) => {
          if (!row || row.length === 0) {
            return;
          }
          const rawName = (row[0] || "").trim().replace(/^"(.+)"$/, "$1");
          if (!rawName) {
            return;
          }
          if (index === 0 && /^(name|names)$/i.test(rawName)) {
            return;
          }
          const contactRaw = row.length > 1 ? row[1] : "";
          const contact = typeof contactRaw === "string" ? contactRaw.trim() : String(contactRaw || "").trim();
          records.push({ name: rawName, contact });
          names.add(rawName);
        });

        memberRecords = records;
        memberNames = Array.from(names).sort((a, b) => a.localeCompare(b));

        nameDatalist.innerHTML = "";
        memberNames.forEach((name) => {
          const option = document.createElement("option");
          option.value = name;
          nameDatalist.appendChild(option);
        });

        document
          .querySelectorAll(".name-select")
          .forEach((select) => populateNameSelect(select));

        renderTable();
      } catch (error) {
        console.warn("Could not load member list", error);
      }
    }

    function formatCurrency(value) {
      if (!Number.isFinite(value)) return "";
      if (Math.abs(value) < 1e-9) return "0";
      const fixed = Number(value).toFixed(2);
      return fixed.replace(/\.00$/, "").replace(/(\.\d*[1-9])0+$/, "$1");
    }

    function toCsvValue(value) {
      if (value === null || value === undefined) {
        return "";
      }
      const stringValue = String(value);
      if (/[",\n]/.test(stringValue)) {
        return `"${stringValue.replace(/"/g, '""')}"`;
      }
      return stringValue;
    }

    function buildTableCsv() {
      const activeExpenses = getActiveExpenses();
      const header = ["Name"];
      activeExpenses.forEach((expense) => {
        header.push(`${expense.name} Amount`);
        header.push(`${expense.name} Consumer`);
      });
      header.push("Notes");

      const rows = [header];
      participants.forEach((participant, personIndex) => {
        const row = [participant.name || ""];
        activeExpenses.forEach((expense) => {
          ensureExpenseSize(expense);
          const amount = expense.amounts[personIndex];
          row.push(amount === "" || amount === null || amount === undefined ? "" : String(amount));
          row.push(expense.consumers[personIndex] ? "1" : "0");
        });
        row.push(participant.notes || "");
        rows.push(row);
      });

      return rows.map((row) => row.map(toCsvValue).join(",")).join("\r\n");
    }

    function downloadAttendanceCsv() {
      const csvContent = buildTableCsv();
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "attendance-table.csv";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    function parseCsv(text) {
      const rows = [];
      let currentRow = [];
      let currentValue = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i += 1) {
        const char = text[i];

        if (inQuotes) {
          if (char === '"') {
            if (text[i + 1] === '"') {
              currentValue += '"';
              i += 1;
            } else {
              inQuotes = false;
            }
          } else {
            currentValue += char;
          }
        } else if (char === '"') {
          inQuotes = true;
        } else if (char === ",") {
          currentRow.push(currentValue);
          currentValue = "";
        } else if (char === "\n") {
          currentRow.push(currentValue);
          rows.push(currentRow);
          currentRow = [];
          currentValue = "";
        } else if (char !== "\r") {
          currentValue += char;
        }
      }

      currentRow.push(currentValue);
      rows.push(currentRow);

      return rows.filter((row) => row.some((value) => value && value.trim() !== ""));
    }

    function normalizeConsumerValue(value) {
      if (value === null || value === undefined) {
        return false;
      }
      const normalized = String(value).trim().toLowerCase();
      if (!normalized) {
        return false;
      }
      return ["1", "true", "yes", "y", "checked", "x"].includes(normalized);
    }

    function syncExpenseToggleStates() {
      document
        .querySelectorAll('.expense-toggle-group input[type="checkbox"]')
        .forEach((checkbox) => {
          const key = checkbox.dataset.expenseKey;
          const expense = baseExpenses.find((item) => item.key === key);
          if (expense) {
            checkbox.checked = expense.enabled;
          }
        });
    }

    function loadTableFromCsvContent(text) {
      const rows = parseCsv(text);
      if (rows.length === 0) {
        window.alert("CSV file is empty.");
        return;
      }

      const header = rows[0];
      if (!header.length || header[0].trim().toLowerCase() !== "name") {
        window.alert('CSV first column must be labeled "Name".');
        return;
      }

      if (header.length < 2 || header[header.length - 1].trim().toLowerCase() !== "notes") {
        window.alert('CSV must include a final column labeled "Notes".');
        return;
      }

      const expenseEntries = [];
      let columnIndex = 1;
      while (columnIndex < header.length - 1) {
        const amountHeader = header[columnIndex];
        const consumerHeader = header[columnIndex + 1];
        if (amountHeader === undefined || consumerHeader === undefined) {
          break;
        }
        const match = amountHeader.match(/^(.*) Amount$/);
        if (!match || consumerHeader !== `${match[1]} Consumer`) {
          window.alert(
            'Expense headers must follow the pattern "<Expense Name> Amount" and "<Expense Name> Consumer".'
          );
          return;
        }
        const expenseName = match[1];
        expenseEntries.push({
          name: expenseName,
          amountIndex: columnIndex,
          consumerIndex: columnIndex + 1
        });
        columnIndex += 2;
      }

      if (columnIndex !== header.length - 1) {
        window.alert("CSV columns could not be interpreted.");
        return;
      }

      const dataRows = rows.slice(1);
      participants.length = 0;

      dataRows.forEach((row) => {
        const nameValue = row[0] ? row[0].trim() : "";
        const notesIndex = header.length - 1;
        const notesValue = row[notesIndex] !== undefined ? row[notesIndex] : "";
        participants.push({ name: nameValue, bold: false, notes: notesValue });
      });

      if (participants.length === 0) {
        participants.push({ name: "", bold: false, notes: "" });
      }

      const includedExpenses = new Set(expenseEntries.map((entry) => entry.name));

      baseExpenses.forEach((expense) => {
        if (includedExpenses.has(expense.name)) {
          expense.enabled = true;
        } else {
          expense.enabled = false;
          expense.amounts = participants.map(() => "");
          expense.consumers = participants.map(() => true);
        }
      });

      for (let index = customExpenses.length - 1; index >= 0; index -= 1) {
        if (!includedExpenses.has(customExpenses[index].name)) {
          customExpenses.splice(index, 1);
        }
      }

      const expenseObjects = expenseEntries.map((entry) => {
        const baseExpense = baseExpenses.find((expense) => expense.name === entry.name);
        if (baseExpense) {
          return baseExpense;
        }
        const existingCustom = customExpenses.find((expense) => expense.name === entry.name);
        if (existingCustom) {
          return existingCustom;
        }
        const newExpense = createExpense({ name: entry.name });
        customExpenses.push(newExpense);
        return newExpense;
      });

      expenseObjects.forEach((expense, expenseIndex) => {
        const amounts = [];
        const consumers = [];
        dataRows.forEach((row, rowIndex) => {
          const amountRaw = row[expenseEntries[expenseIndex].amountIndex];
          const consumerRaw = row[expenseEntries[expenseIndex].consumerIndex];
          const trimmedAmount = amountRaw === undefined ? "" : String(amountRaw).trim();
          if (trimmedAmount === "") {
            amounts[rowIndex] = "";
          } else {
            const numericAmount = Number(trimmedAmount);
            amounts[rowIndex] = Number.isFinite(numericAmount) ? numericAmount : "";
          }
          consumers[rowIndex] = normalizeConsumerValue(consumerRaw);
        });
        while (amounts.length < participants.length) {
          amounts.push("");
          consumers.push(true);
        }
        expense.amounts = amounts;
        expense.consumers = consumers;
        if (baseExpenses.includes(expense)) {
          expense.enabled = true;
        }
        if (isBaseRateControlled(expense)) {
          const definedValues = expense.amounts.filter((value) => value !== "");
          if (definedValues.length === 0) {
            baseExpenseRates[expense.key] = "";
          } else {
            const firstValue = definedValues[0];
            const uniform = expense.amounts.every(
              (value) => value === "" || value === firstValue
            );
            if (uniform) {
              baseExpenseRates[expense.key] = firstValue;
              applyBaseExpenseRateToExpense(expense.key);
            } else {
              baseExpenseRates[expense.key] = "";
            }
          }
        }
      });

      syncBaseExpenseInputsFromRates();
      syncExpenseToggleStates();
      renderTable();
    }

    function ensureExpenseSize(expense) {
      const needed = participants.length;
      const rateKey = isBaseRateControlled(expense) ? expense.key : null;
      const rateValue = rateKey ? baseExpenseRates[rateKey] : null;
      while (expense.amounts.length < needed) {
        if (rateKey) {
          expense.amounts.push(rateValue === "" ? "" : rateValue);
        } else {
          expense.amounts.push("");
        }
      }
      while (expense.consumers.length < needed) {
        expense.consumers.push(true);
      }
      while (expense.amounts.length > needed) {
        expense.amounts.pop();
      }
      while (expense.consumers.length > needed) {
        expense.consumers.pop();
      }
    }

    function syncAllExpenseSizes() {
      getAllExpenses().forEach(ensureExpenseSize);
    }

    function renderTable() {
      syncAllExpenseSizes();
      const activeExpenses = getActiveExpenses();

      const headerRow = document.getElementById("attendance-header");
      headerRow.innerHTML = "";
      const nameHeader = document.createElement("th");
      nameHeader.textContent = "Name";
      headerRow.appendChild(nameHeader);

      activeExpenses.forEach((expense) => {
        const amountHeader = document.createElement("th");
        amountHeader.textContent = `${expense.name} ($)`;
        amountHeader.dataset.expenseId = expense.id;
        headerRow.appendChild(amountHeader);

        const consumeHeader = document.createElement("th");
        consumeHeader.className = "consume-header";
        consumeHeader.dataset.expenseId = expense.id;
        headerRow.appendChild(consumeHeader);
      });

      const breakdownHeader = document.createElement("th");
      breakdownHeader.textContent = "Fee Breakdown";
      headerRow.appendChild(breakdownHeader);

      const feeHeader = document.createElement("th");
      feeHeader.textContent = "Fee ($)";
      headerRow.appendChild(feeHeader);

      const reimbHeader = document.createElement("th");
      reimbHeader.textContent = "Reimbursed ($)";
      headerRow.appendChild(reimbHeader);

      const notesHeader = document.createElement("th");
      notesHeader.textContent = "Notes";
      headerRow.appendChild(notesHeader);

      renderBody(activeExpenses);
      renderFooter(activeExpenses);
      updateDuplicateNameWarnings();
      recalculate();
    }

    function renderBody(activeExpenses) {
      const tbody = document.getElementById("attendance-body");
      tbody.innerHTML = "";

      participants.forEach((participant, personIndex) => {
        const row = document.createElement("tr");

        const nameCell = document.createElement("td");
        const nameWrapper = document.createElement("div");
        nameWrapper.className = "name-input-wrapper";

        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.value = participant.name;
        nameInput.setAttribute("list", nameListId);
        nameInput.className = "name-input" + (participant.bold ? " bold" : "");
        nameInput.dataset.personIndex = String(personIndex);

        const nameSelect = document.createElement("select");
        nameSelect.className = "name-select";
        nameSelect.dataset.personIndex = String(personIndex);
        nameSelect.setAttribute("aria-label", "Select member from list");
        nameSelect.title = "Select member";
        populateNameSelect(nameSelect);

        nameInput.addEventListener("input", (event) => {
          const value = event.target.value;
          participants[personIndex].name = value;
          if (!memberNames.includes(value)) {
            nameSelect.value = "";
          }
          recalculate();
          updateDuplicateNameWarnings();
        });

        nameInput.addEventListener("keydown", (event) => {
          if (event.key !== "Tab" || event.shiftKey) {
            return;
          }
          const nextIndex = personIndex + 1;
          const nextInput = document.querySelector(
            `.name-input[data-person-index="${nextIndex}"]`
          );
          if (!nextInput) {
            return;
          }
          event.preventDefault();
          nextInput.focus();
        });

        nameSelect.addEventListener("change", (event) => {
          const value = event.target.value;
          participants[personIndex].name = value;
          nameInput.value = value;
          recalculate();
          event.target.value = "";
          updateDuplicateNameWarnings();
        });

        nameWrapper.appendChild(nameInput);
        nameWrapper.appendChild(nameSelect);
        nameCell.appendChild(nameWrapper);
        row.appendChild(nameCell);

        activeExpenses.forEach((expense) => {
          ensureExpenseSize(expense);
          const amountCell = document.createElement("td");
          const amountInput = document.createElement("input");
          amountInput.type = "number";
          amountInput.step = "0.01";
          amountInput.value = expense.amounts[personIndex] !== "" ? expense.amounts[personIndex] : "";
          amountInput.placeholder = "0.00";
          amountInput.dataset.expenseId = expense.id;
          amountInput.dataset.personIndex = String(personIndex);
          if (isBaseRateControlled(expense)) {
            const rate = baseExpenseRates[expense.key];
            amountInput.value = rate === "" ? "" : rate;
            amountInput.readOnly = true;
            amountInput.tabIndex = -1;
            amountInput.classList.add("read-only-amount");
            amountInput.setAttribute(
              "title",
              `${expense.name} is managed from the controls above.`
            );
            amountInput.setAttribute("aria-readonly", "true");
          }
          amountInput.addEventListener("input", (event) => {
            if (event.target.readOnly) {
              return;
            }
            const targetExpense = findExpenseById(event.target.dataset.expenseId);
            if (!targetExpense) {
              return;
            }
            const index = Number(event.target.dataset.personIndex);
            const value = event.target.value.trim();
            targetExpense.amounts[index] = value === "" ? "" : Number(value);
            recalculate();
          });
          amountCell.appendChild(amountInput);
          row.appendChild(amountCell);

          const consumeCell = document.createElement("td");
          consumeCell.className = "consume-cell";
          const consumeInput = document.createElement("input");
          consumeInput.type = "checkbox";
          consumeInput.checked = Boolean(expense.consumers[personIndex]);
          consumeInput.dataset.expenseId = expense.id;
          consumeInput.dataset.personIndex = String(personIndex);
          consumeInput.addEventListener("change", (event) => {
            const targetExpense = findExpenseById(event.target.dataset.expenseId);
            if (!targetExpense) {
              return;
            }
            const index = Number(event.target.dataset.personIndex);
            targetExpense.consumers[index] = event.target.checked;
            recalculate();
          });
          consumeCell.appendChild(consumeInput);
          row.appendChild(consumeCell);
        });

        const breakdownCell = document.createElement("td");
        breakdownCell.className = "fee-breakdown";
        breakdownCell.dataset.personIndex = personIndex;
        row.appendChild(breakdownCell);

        const feeCell = document.createElement("td");
        feeCell.className = "fee-value";
        feeCell.dataset.personIndex = personIndex;
        row.appendChild(feeCell);

        const reimbCell = document.createElement("td");
        reimbCell.className = "reimbursed-value";
        reimbCell.dataset.personIndex = personIndex;
        row.appendChild(reimbCell);

        const notesCell = document.createElement("td");
        const notesInput = document.createElement("textarea");
        notesInput.value = participant.notes;
        notesInput.addEventListener("input", (event) => {
          participants[personIndex].notes = event.target.value;
        });
        notesCell.appendChild(notesInput);
        row.appendChild(notesCell);

        tbody.appendChild(row);
      });
    }

    function renderFooter(activeExpenses) {
      const tfoot = document.getElementById("attendance-foot");
      tfoot.innerHTML = "";
      const row = document.createElement("tr");
      row.className = "totals-row";

      const blankCell = document.createElement("td");
      blankCell.textContent = "";
      row.appendChild(blankCell);

      activeExpenses.forEach((expense) => {
        const totalCell = document.createElement("td");
        totalCell.className = "expense-total";
        totalCell.dataset.expenseId = expense.id;
        totalCell.textContent = "Total: $0";
        row.appendChild(totalCell);

        const consumersCell = document.createElement("td");
        consumersCell.className = "expense-consumers";
        consumersCell.dataset.expenseId = expense.id;
        consumersCell.textContent = "Consumers: 0";
        row.appendChild(consumersCell);
      });

      const breakdownCell = document.createElement("td");
      breakdownCell.innerHTML = "<strong>Total</strong>";
      row.appendChild(breakdownCell);

      const feeCell = document.createElement("td");
      feeCell.className = "fee-value total-fee";
      row.appendChild(feeCell);

      const reimbCell = document.createElement("td");
      reimbCell.className = "reimbursed-value total-reimbursed";
      row.appendChild(reimbCell);

      const noteCell = document.createElement("td");
      noteCell.innerHTML = "<em>(if filled, continue on back)</em>";
      row.appendChild(noteCell);

      tfoot.appendChild(row);
    }

    function recalculate() {
      const activeExpenses = getActiveExpenses();
      const participantFeeTotals = new Array(participants.length).fill(0);
      const participantFeeBreakdowns = participants.map(() => []);
      const participantContributions = new Array(participants.length).fill(0);
      let clubIncome = 0;

      activeExpenses.forEach((expense) => {
        ensureExpenseSize(expense);
        let total = 0;
        const consumers = [];

        expense.amounts.forEach((amount, personIndex) => {
          const participant = participants[personIndex];
          const hasName = Boolean(participant.name && participant.name.trim());
          if (hasName && amount !== "" && Number.isFinite(Number(amount))) {
            total += Number(amount);
            participantContributions[personIndex] += Number(amount);
          }
          if (hasName && expense.consumers[personIndex]) {
            consumers.push(personIndex);
          }
        });

        const consumerCount = consumers.length;
        const share = consumerCount > 0 ? total / consumerCount : 0;

        consumers.forEach((personIndex) => {
          participantFeeTotals[personIndex] += share;
          if (share > 0) {
            participantFeeBreakdowns[personIndex].push({
              name: expense.name,
              value: share
            });
          }
          if (expense.key === "personal-gear" || expense.key === "shared-gear") {
            clubIncome += share;
          }
        });

        const totalCell = document.querySelector(
          `.expense-total[data-expense-id="${expense.id}"]`
        );
        if (totalCell) {
          const totalText = formatCurrency(total);
          totalCell.textContent = `Total: $${totalText || "0"}`;
        }
        const consumersCell = document.querySelector(
          `.expense-consumers[data-expense-id="${expense.id}"]`
        );
        if (consumersCell) {
          const shareText = consumerCount > 0 ? `Share: $${formatCurrency(share) || "0"}` : "Share: $0";
          consumersCell.innerHTML = `<div>Consumers: ${consumerCount}</div><div>${shareText}</div>`;
        }
      });

      let totalFees = 0;
      let totalReimbursed = 0;

      participants.forEach((participant, personIndex) => {
        const hasName = Boolean(participant.name && participant.name.trim());
        const fee = hasName ? participantFeeTotals[personIndex] : 0;
        const contributions = hasName ? participantContributions[personIndex] : 0;
        const reimbursed = contributions - fee;

        if (hasName) {
          totalFees += fee;
          totalReimbursed += reimbursed;
        }

        const breakdownCell = document.querySelector(
          `.fee-breakdown[data-person-index="${personIndex}"]`
        );
        const feeCell = document.querySelector(
          `.fee-value[data-person-index="${personIndex}"]`
        );
        const reimbCell = document.querySelector(
          `.reimbursed-value[data-person-index="${personIndex}"]`
        );

        if (breakdownCell) {
          if (hasName) {
            const breakdown = participantFeeBreakdowns[personIndex];
            breakdownCell.textContent = breakdown.length
              ? breakdown
                  .map((entry) => `${entry.name}: $${formatCurrency(entry.value) || "0"}`)
                  .join("; ")
              : "";
          } else {
            breakdownCell.textContent = "";
          }
        }
        if (feeCell) {
          feeCell.textContent = hasName && fee ? `$${formatCurrency(fee)}` : "";
        }
        if (reimbCell) {
          if (hasName && reimbursed) {
            const prefix = reimbursed < 0 ? "-$" : "$";
            reimbCell.textContent = `${prefix}${formatCurrency(Math.abs(reimbursed))}`;
          } else {
            reimbCell.textContent = "";
          }
        }
      });

      const totalFeeCell = document.querySelector(".total-fee");
      if (totalFeeCell) {
        totalFeeCell.textContent = totalFees ? `$${formatCurrency(totalFees)}` : "";
      }

      const totalReimbCell = document.querySelector(".total-reimbursed");
      if (totalReimbCell) {
        const prefix = totalReimbursed < 0 ? "-$" : "$";
        totalReimbCell.textContent = totalReimbursed
          ? `${prefix}${formatCurrency(Math.abs(totalReimbursed))}`
          : "";
      }

      const clubIncomeCell = document.getElementById("club-income-value");
      if (clubIncomeCell) {
        clubIncomeCell.textContent = clubIncome ? `$${formatCurrency(clubIncome)}` : "";
      }
    }

    document.getElementById("add-expense").addEventListener("click", () => {
      const expenseName = window.prompt("Enter a name for the new expense:");
      if (!expenseName) {
        return;
      }
      const trimmed = expenseName.trim();
      if (!trimmed) {
        return;
      }
      customExpenses.push(createExpense({ name: trimmed }));
      renderTable();
    });

    document.getElementById("remove-expense").addEventListener("click", () => {
      if (customExpenses.length === 0) {
        window.alert("There are no custom expenses to remove.");
        return;
      }
      const namesList = customExpenses.map((expense) => expense.name).join(", ");
      const targetName = window.prompt(
        `Enter the name of the expense to remove:\n${namesList}`
      );
      if (!targetName) {
        return;
      }
      const trimmed = targetName.trim().toLowerCase();
      const index = customExpenses.findIndex(
        (expense) => expense.name.toLowerCase() === trimmed
      );
      if (index === -1) {
        window.alert(`Could not find an expense named "${targetName}".`);
        return;
      }
      customExpenses.splice(index, 1);
      renderTable();
    });

    document.getElementById("save-csv").addEventListener("click", () => {
      downloadAttendanceCsv();
    });

    const loadCsvInput = document.getElementById("load-csv-input");
    document.getElementById("load-csv").addEventListener("click", () => {
      loadCsvInput.value = "";
      loadCsvInput.click();
    });

    loadCsvInput.addEventListener("change", (event) => {
      const [file] = event.target.files;
      if (!file) {
        return;
      }
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const result = reader.result;
          const textContent = typeof result === "string" ? result : new TextDecoder().decode(result);
          loadTableFromCsvContent(textContent);
        } catch (error) {
          console.error("Could not load CSV", error);
          window.alert("Could not load CSV. Please check the file format.");
        }
      };
      reader.readAsText(file);
    });

    const notifyButton = document.getElementById("notify-button");
    if (notifyButton) {
      notifyButton.addEventListener("click", () => {
        openNotifyDialog();
      });
    }

    const notifyClose = document.getElementById("notify-close");
    if (notifyClose) {
      notifyClose.addEventListener("click", () => {
        closeNotifyDialog();
      });
    }

    const notifyDialog = document.getElementById("notify-dialog");
    if (notifyDialog) {
      notifyDialog.addEventListener("cancel", (event) => {
        event.preventDefault();
        closeNotifyDialog();
      });
      notifyDialog.addEventListener("click", (event) => {
        const rect = notifyDialog.getBoundingClientRect();
        const isInDialog =
          event.clientX >= rect.left &&
          event.clientX <= rect.right &&
          event.clientY >= rect.top &&
          event.clientY <= rect.bottom;
        if (!isInDialog) {
          closeNotifyDialog();
        }
      });
    }

    document.getElementById("add-row").addEventListener("click", () => {
      participants.push({ name: "", bold: false, notes: "" });
      renderTable();
    });

    document.getElementById("remove-row").addEventListener("click", () => {
      if (participants.length === 0) {
        return;
      }
      const lastParticipant = participants[participants.length - 1];
      const hasName = Boolean(lastParticipant?.name && lastParticipant.name.trim());
      if (hasName && !window.confirm("Remove the last participant row?")) {
        return;
      }
      participants.pop();
      renderTable();
    });

    document
      .querySelectorAll('.expense-toggle-group input[type="checkbox"]')
      .forEach((checkbox) => {
        const key = checkbox.dataset.expenseKey;
        const expense = baseExpenses.find((item) => item.key === key);
        if (!expense) {
          return;
        }
        checkbox.checked = expense.enabled;
        checkbox.addEventListener("change", (event) => {
          expense.enabled = event.target.checked;
          renderTable();
        });
      });

    async function loadSignature() {
      try {
        const response = await fetch("signature.txt");
        if (!response.ok) {
          return;
        }
        const text = await response.text();
        const signatureCell = document.getElementById("signature-output");
        const commentsField = document.getElementById("signature-comments");
        const cleaned = text.trim();
        if (signatureCell) {
          signatureCell.textContent = cleaned;
        }
        if (commentsField) {
          commentsField.value = cleaned;
        }
      } catch (error) {
        console.warn("Could not load signature", error);
      }
    }

    syncBaseExpenseInputsFromRates();
    loadMemberOptions();
    renderTable();
    loadSignature();
  </script>
</body>
</html>
